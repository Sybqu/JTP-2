# 1. buffer overflow 0

> Let's start off simple, can you overflow the correct buffer? The program is available here. You can view source here.
Connect using:
nc saturn.picoctf.net 64666

## Solution:

- Literally i read overflow and input a big ahh string Which gave me the flag
- Our code reads our input and inputs it into flag <global var>
- The signal handler tells the function to run the function "sigsegv_handler()" before dying in case of segmentation fault
- gets() reads input of buf1 into buf2 . Gets does not check the length of the string even strcpy
- buf2 is allocated 16bits .
- Over flow does not happen at 16 bits. but after 24 bits. when the register bits are used as well
 - buf2->register->return address
- After 24 bits return address gets corrupted
- Vuln() tries to return but nuh in valid address -> segfault -> printflag


## Flag:

```
picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}

```

## Concepts learnt:

- Buffer Overflow
 - Buffer : A block of memory that stores temp data <array>
 - Buffer overflow: writing beyond the allocated buffer space
- The stack
 - memory region that stores local variables
 - Registers
 - function return addresses

## Notes:

- after the initial guess i had to spend some time understanding all of this
- 

## Resources:

- Include the resources you've referred to with links. [example hyperlink](https://google.com)


***

# 2. Challenge name

> Description

.
.
.
