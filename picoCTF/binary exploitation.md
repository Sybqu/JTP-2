# 1. buffer overflow 0

> Let's start off simple, can you overflow the correct buffer? The program is available here. You can view source here.
Connect using:
nc saturn.picoctf.net 64666

## Solution:

- Literally i read overflow and input a big ahh string Which gave me the flag
- Our code reads our input and inputs it into flag <global var>
- The signal handler tells the function to run the function "sigsegv_handler()" before dying in case of segmentation fault
- gets() reads input of buf1 into buf2 . Gets does not check the length of the string even strcpy
- buf2 is allocated 16bits .
- Over flow does not happen at 16 bits. but after 24 bits. when the register bits are used as well
 - buf2->register->return address
- After 24 bits return address gets corrupted
- Vuln() tries to return but nuh in valid address -> segfault -> printflag


## Flag:

```
picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}

```

## Concepts learnt:

- Buffer Overflow
 - Buffer : A block of memory that stores temp data <array>
 - Buffer overflow: writing beyond the allocated buffer space
- The stack
 - memory region that stores local variables
 - Registers
 - function return addresses

## Notes:

- after the initial guess i had to spend some time understanding all of this
- 

## Resources:

- Include the resources you've referred to with links. [example hyperlink](https://google.com)


***


# 2. format-string-0

> Can you use your knowledge of format strings to make the customers happy?
  Download the binary here.
  Download the source here.
  Additional details will be available after launching your challenge instance.


## Solution:

- Much like the buffer overflow challenge
- There is a signal handler
- So if we make a segmentation fault occur it prints the flag
- 2 main functions :- serve_patrick() and serve_bob()
 - Serve_patrick()
  - if printf(choice1)>64 we proceed to serve_bob()
  - Gr%114d_Cheese option takes care of that <format specifier : %d>
- Serve_bob()
 - Now we need to segfault this
 - We need to choose the option which does not have a pointer address
 - If the pointer address does not exist it'll fetch a %s will fetch a garbage address and segfault 


## Flag:

```
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_ef312157}
```

## Concepts learnt:

- string vulnerability
- Pointer address importance

## Notes:

- easy enough

## Resources:

- Include the resources you've referred to with links. [example hyperlink](https://google.com)


***

> Let's start off simple, can you overflow the correct buffer? The program is available here. You can view source here.
Connect using:
nc saturn.picoctf.net 64666

## Solution:

- Literally i read overflow and input a big ahh string Which gave me the flag
- Our code reads our input and inputs it into flag <global var>
- The signal handler tells the function to run the function "sigsegv_handler()" before dying in case of segmentation fault
- gets() reads input of buf1 into buf2 . Gets does not check the length of the string even strcpy
- buf2 is allocated 16bits .
- Over flow does not happen at 16 bits. but after 24 bits. when the register bits are used as well
 - buf2->register->return address
- After 24 bits return address gets corrupted
- Vuln() tries to return but nuh in valid address -> segfault -> printflag


## Flag:

```
picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}

```

## Concepts learnt:

- Buffer Overflow
 - Buffer : A block of memory that stores temp data <array>
 - Buffer overflow: writing beyond the allocated buffer space
- The stack
 - memory region that stores local variables
 - Registers
 - function return addresses

## Notes:

- after the initial guess i had to spend some time understanding all of this
- 

## Resources:

- Include the resources you've referred to with links. [example hyperlink](https://google.com)


# 3. Clutter-overflow

> Clutter, clutter everywhere and not a byte to use.
  nc mars.picoctf.net 31890

## Solution:

- Firstly had to understand the stack layout
- Controlled buffer overflow
- Had to find the offset at which buffer overflow occurs
- The clutter buffer is 256 bytes + 8 register bytes
- So offset = 264
- Then used payload in little endian format and boom flag

 ```python

from pwn import *

fname = './chall'

r = remote('mars.picoctf.net', 31890)

r.sendline(b'A' * 264 + p64(0xdeadbeef))

r.interactive()


```


## Flag:

```
picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}
```

## Concepts learnt:

- Controlled Buffer Overflow
 - Stack layout
 - Register and padding bytes
 - pwn_tools
## Notes:
- i was having lotsss of problems with raw python script
 even tho i confirmed the offset was 264 it wasnt giving the flag
 -  Had to use pwn_tools to overcome this
 - And im not sure yet that the 256 + 8 bytes were for clutter and register/padding. confused between register and padding.

## Resources:

- Include the resources you've referred to with links. [example hyperlink](https://google.com)


***


***
